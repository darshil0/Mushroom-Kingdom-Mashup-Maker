/**
 * Mushroom Kingdom Mashup Maker - Gemini Service Tests
 * Ensures the integration with the Google GenAI SDK is correct and robust.
 */

import { generateLevel } from './geminiService';
// FIX 1: Explicitly import Type and GoogleGenAI for type safety and access
import { GoogleGenAI, Type } from '@google/genai'; 
import { EntityType } from '../types';

// Mock the GoogleGenAI library and define the mock generateContent function outside
const mockGenerateContent = jest.fn();

// FIX 2: Enhance the mock to include the correct data structure, including entities
const MOCK_SUCCESS_RESPONSE = {
  name: "Test Level",
  layout: "S...........................................................\n".repeat(15),
  description: "A test level description generated by Gemini.",
  entities: [
    { type: EntityType.Goomba, x: 5, y: 14 },
    { type: EntityType.Coin, x: 20, y: 5 },
  ],
  prompt: "A simple test level",
};

jest.mock('@google/genai', () => ({
  GoogleGenAI: jest.fn().mockImplementation(() => ({
    models: {
      generateContent: mockGenerateContent,
    }
  })),
  Type: {
    OBJECT: 'OBJECT',
    STRING: 'STRING',
    ARRAY: 'ARRAY', // FIX 3: Added missing Type.ARRAY for complete schema
    NUMBER: 'NUMBER',
  }
}));

describe('geminiService', () => {
  beforeEach(() => {
    // Set the default successful mock implementation
    mockGenerateContent.mockResolvedValue({
      text: JSON.stringify(MOCK_SUCCESS_RESPONSE),
    });
    jest.clearAllMocks();
  });

  it('should generate a level successfully and validate response structure', async () => {
    const prompt = 'A simple test level focusing on jumping';
    const result = await generateLevel(prompt);

    // FIX 4: Validate that the SDK was initialized and called with the correct model and prompt
    expect(GoogleGenAI).toHaveBeenCalledWith({ apiKey: expect.any(String) });
    expect(mockGenerateContent).toHaveBeenCalledWith({
      model: 'gemini-2.5-flash',
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      config: expect.objectContaining({
        // Validate function calling structure
        responseMimeType: 'application/json',
        responseSchema: expect.objectContaining({ type: Type.OBJECT }),
        temperature: 0.8,
      }),
    });
    
    // Validate result structure, including the entities array
    expect(result).toEqual(MOCK_SUCCESS_RESPONSE);
    expect(result.entities.length).toBe(2);
    expect(result.entities[0].type).toBe(EntityType.Goomba);
    expect(result).toHaveProperty('prompt', prompt); // FIX 5: Ensure prompt is included in the result
  });

  it('should handle API errors gracefully', async () => {
    mockGenerateContent.mockRejectedValue(new Error('API Rate Limit Exceeded'));

    await expect(generateLevel('fail')).rejects.toThrow('API Rate Limit Exceeded');
  });

  it('should handle malformed JSON response from the model', async () => {
    // Mock a response where the model forgets the quotes or brackets
    mockGenerateContent.mockResolvedValue({
      text: '{ name: "Bad JSON", layout: "..." }', 
    });

    // FIX 6: Expect an error when JSON parsing fails
    await expect(generateLevel('malformed')).rejects.toThrow('Failed to parse level JSON');
    // Ensure the original error message includes 'Unexpected token' or similar
    await expect(generateLevel('malformed')).rejects.toHaveProperty('cause');
  });
});
